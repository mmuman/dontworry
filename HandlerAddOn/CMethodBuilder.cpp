//========================================================================
//	CMethodBuilder.cpp
//========================================================================	

#include <String.h>
#include <ctype.h>
#include <ByteOrder.h>
#include <Entry.h>
#include <Path.h>
#include <Application.h>
#include <Control.h>

#include "AddOnConstantes.h"
#include "CMethodBuilder.h"
#include "PlugInPreferences.h"
#include "MProject.h"
#include "ErrorMessage.h"
#include "CAddOnAppHandler.h"
#include "CMethodMessageFilter.h"

#include <iostream.h>

/**** ajouter le handler ****/
CMethodBuilder::CMethodBuilder()
{
	// augmenter le compteur d'ajout du Handler
	CreateAddOnHandler();
}

/**** Destructeur ****/
CMethodBuilder::~CMethodBuilder()
{
	DestroyAddOnHandler();
}

/**** creer le Handler (l'ajouter ou augmenter le compteur d'ajout) ****/
void CMethodBuilder::CreateAddOnHandler()
{
	// Ajouter le Handler si il n'existe pas
	int32				nbHandler = 0;
	BString				nameHandler("");
	CAddOnAppHandler	*addOnHandler = NULL;

	// bloquer l'application
	be_app->Lock();
	
	// regarder tous les handlers de l'application
	nbHandler = be_app->CountHandlers();
	for(int32 index=0;index<nbHandler;index++)
	{
		nameHandler = (be_app->HandlerAt(index))->Name();
		if(nameHandler.FindFirst(ADDON_HANDLER_NAME)!=B_ERROR)
		{
			addOnHandler = (CAddOnAppHandler *)(be_app->HandlerAt(index));
			be_app->Unlock();

			// on a trouvé on l'installe pas
			return;
		}
	}

	// si on arrive la, on a pas trouver notre Handler
	be_app->Lock();
	addOnHandler = new CAddOnAppHandler();
	be_app->AddHandler(addOnHandler);
	be_app->AddFilter(new CMethodMessageFilter(addOnHandler));
	be_app->Unlock();

	// creation du messenger sur le handler
	_handler = BMessenger(addOnHandler);	

	be_app->Unlock();
}

/**** detruire le Handler (l'enlever ou diminuer le compteur d'ajout) ****/
void CMethodBuilder::DestroyAddOnHandler()
{
	// on cherche notre handler
	int32			nbHandler = 0;
	BString			nameHandler("");
	BHandler		*addOnHandler;
	int32			nbFilter;
	BMessageFilter	*filter;
	
	// bloquer l'application
	be_app->Lock();

	// on va en premier enlever notre BMessageFilter
	nbFilter = be_app->FilterList()->CountItems();
	for(int32 filterIndex=0;filterIndex<nbFilter;filterIndex++)
	{
		filter = (BMessageFilter *)(be_app->FilterList()->ItemAt(filterIndex));
		if(dynamic_cast<CMethodMessageFilter *>(filter) != NULL)
			be_app->RemoveFilter(filter);
	}
	
	// rechercher parmi tous les handler de l'application
	nbHandler = be_app->CountHandlers();
	for(int32 index=0;index<nbHandler;index++)
	{
		addOnHandler = be_app->HandlerAt(index);
		nameHandler = addOnHandler->Name();
		if(nameHandler.FindFirst(ADDON_HANDLER_NAME)!=B_ERROR)
		{
			// on a trouvé				
			if(be_app->RemoveHandler(addOnHandler))
				delete addOnHandler;
			
			// sortir de la boucle
			break;
		}
	}
	
	// debloquer l'application
	be_app->Unlock();
}

// ---------------------------------------------------------------------------
//	GetToolName
// ---------------------------------------------------------------------------
//	return the name of the tool for which this builder object generates
//	command lines.

long CMethodBuilder::GetToolName(MProject* /* inProject */,char* outName,long	 /*inBufferLength*/,MakeStageT /*inStage*/,MakeActionT /*inAction*/)
{
//	strcpy(outName, shellToolName);

	return B_NO_ERROR;
}

// ---------------------------------------------------------------------------
//	LinkerName
// ---------------------------------------------------------------------------
//	return the name of the linker that will link the target files
//	generated by this tool.  This tool's pluginview will only
//	be shown if it matches the tool for the specified project.
//	An empty string matches all linkers.
//	The shell tool isn't associated with a particular linker so
//	it returns an empty string.

const char *CMethodBuilder::LinkerName()
{
	return B_EMPTY_STRING;
}


// ---------------------------------------------------------------------------
//	MakeStages
// ---------------------------------------------------------------------------

MakeStageT CMethodBuilder::MakeStages()
{
	return (kIgnoreStage);
}

// ---------------------------------------------------------------------------
//	Actions
// ---------------------------------------------------------------------------

MakeActionT CMethodBuilder::Actions()
{
	return (kInvalidAction);
}

// ---------------------------------------------------------------------------
//	Flags
// ---------------------------------------------------------------------------

PlugInFlagsT CMethodBuilder::Flags()
{
	return kNotIDEAware;
}

// ---------------------------------------------------------------------------
//	MessageDataType
// ---------------------------------------------------------------------------

ulong CMethodBuilder::MessageDataType()
{
	return 0;
}

// ---------------------------------------------------------------------------
//	BuildPrecompileArgv
// ---------------------------------------------------------------------------

long CMethodBuilder::BuildPrecompileArgv(MProject& inProject,BList& inArgv,MFileRec& inFileRec)
{
	return B_NO_ERROR;
}

// ---------------------------------------------------------------------------
//	BuildCompileArgv
// ---------------------------------------------------------------------------

long CMethodBuilder::BuildCompileArgv(MProject& inProject,BList& inArgv,MakeActionT /*inAction*/,MFileRec& inFileRec)
{
	return B_NO_ERROR;
}

// ---------------------------------------------------------------------------
//	BuildPostLinkArgv
// ---------------------------------------------------------------------------

long CMethodBuilder::BuildPostLinkArgv(MProject& inProject,BList& inArgv,MFileRec& inFileRec)
{
	return B_NO_ERROR;
}

// ---------------------------------------------------------------------------
//	ValidateSettings
// ---------------------------------------------------------------------------
//	Validate the settings in the message.  If they are not valid for this
//	version of the plug-in or they don't exist then a valid prefs struct is
//	added to the message.

bool CMethodBuilder::ValidateSettings(BMessage&	inOutMessage)
{
	return false;
}

// ---------------------------------------------------------------------------
//	ParseMessageText
// ---------------------------------------------------------------------------
//	Read the message text and break it into ErrorMessages.  Add each
//	ErrorMessage to the BList.  The text is redirected output of stderr and
//	stdout.  The text is guaranteed to be null terminated.
//	if a line of text begins with the token ';;' it is considered to be a warning
//	all other text becomes an error.
//	this allows use of echo ";;some info text" to be used in the shell script.

long CMethodBuilder::ParseMessageText(MProject&  inProject ,const char* inText,BList& outList)
{
	return B_NO_ERROR;
}

// ---------------------------------------------------------------------------
//	CodeDataSize
// ---------------------------------------------------------------------------

void CMethodBuilder::CodeDataSize(MProject&  inProject ,const char* inFilePath,long& outCodeSize,long& outDataSize)
{
	outCodeSize = -1;
	outDataSize = -1;
}

// ---------------------------------------------------------------------------
//	GenerateDependencies
// ---------------------------------------------------------------------------

long CMethodBuilder::GenerateDependencies(MProject& inProject ,const char* inFilePath,BList& outList)
{
	return B_ERROR;
}

// ---------------------------------------------------------------------------
//	FileIsDirty
// ---------------------------------------------------------------------------
//	return true if the file is dirty and needs to be executed as part of a 
//	make or bring up to date.
//	We always execute shell scripts so always return true.

bool CMethodBuilder::FileIsDirty(MProject& inProject ,MFileRec& inFileRec,MakeStageT inStage,MakeActionT inAction,time_t inModDate)
{
	return false;
}

// ---------------------------------------------------------------------------
//	GetTargetFilePaths
// ---------------------------------------------------------------------------
//	Fill the list with the full paths to the target file(s) generated
//	when the source file is compiled.  This function is called when
//	the linker needs to know which files to link, and when the user
//	chooses the remove objects menu item.
//	The path must be allocated with malloc.  If no target files
//	are generated then simply return.

void CMethodBuilder::GetTargetFilePaths(MProject& inProject ,MFileRec& inFileRec,BList& inOutTargetFileList)
{
}

// ---------------------------------------------------------------------------
//	ProjectChanged
// ---------------------------------------------------------------------------
//	The MProject callback object allows the builder object to find
//	out various kinds of information about the current project.
//	The MProject object passed in can be cached by the builder object
//	and used at a later time.  It will be valid between calls that 
//	specify kProjectOpened and the matching kProjectClosed.
//	The shell tool doesn't use this info so it doesn't do anything
//	for this callback.
void CMethodBuilder::ProjectChanged(MProject& inProject,ChangeT inChange)
{
	entry_ref	projectRef;
	char 		nameEntry[B_FILE_NAME_LENGTH];

	// le nom du projet
	inProject.GetProjectRef(projectRef);
	BEntry	projectFile(&projectRef);
	// on reprend et le nom
	projectFile.GetName(nameEntry);
	
	switch (inChange)
	{
		case kProjectOpened:
			{
				// on ouvre un nouveau projet
				BMessage				msg(OPEN_PROJECT_FILE);
				BList					projectList;
				BList					systemList;
				bool					state;
				BPath					directoryPath;
				BDirectory				dir;
				BPath					pathEntry;
								
				// on reprend et le chemin
				msg.AddString(PROJECT_FILE_NAME,nameEntry);
				projectFile.GetPath(&pathEntry);
				pathEntry.GetParent(&pathEntry);
				msg.AddString(PROJECT_FILE_PATH,pathEntry.Path());
				
				// on reprend les donnees
				inProject.GetAccessDirectories(projectList,systemList,state);

				// on ajoute les chemins systeme
				for(int32 i=0;i<systemList.CountItems();i++)
				{
					dir = ((AccessDirectoryInfo *)systemList.ItemAt(i))->fDirectory;
					directoryPath.SetTo(&dir,NULL,false);
					msg.AddString(SYSTEM_PATH,directoryPath.Path());
				}
				
				// on ajoute les chemins du projet
				for(int32 i=0;i<projectList.CountItems();i++)
				{
					dir = ((AccessDirectoryInfo *)projectList.ItemAt(i))->fDirectory;
					directoryPath.SetTo(&dir,NULL,false);
					msg.AddString(PROJECT_PATH,directoryPath.Path());
				}

				// on retient les fichiers que le projet possede
				MFileRec	file;			
				for(int32 i=1;i<inProject.FileCount();i++)
				{
					inProject.GetNthFile(file,i);
					msg.AddString(FILE_PATHNAME,file.path);
				}

				// on poste a l'application qui va redirige dans notre handler
				_handler.SendMessage(&msg);
				
			}
			break;
		// on ajoute un fichier au projet
		case kFilesAdded:
			{
				BMessage	msg(ADD_FILE_MSG);
				MFileRec	file;
				
				// envoyer la liste actuelle des fichiers dans le projet
				msg.AddString(PROJECT_FILE_NAME,nameEntry);
				for(int32 i=0;i<inProject.FileCount();i++)
				{
					inProject.GetNthFile(file,i);
					msg.AddString(FILE_PATHNAME,file.path);
				}
				
				_handler.SendMessage(&msg);				
			}
			break;
		case kFilesRemoved:
			{
				BMessage	msg(REMOVE_FILE_MSG);
				MFileRec	file;
				
				// envoyer la liste actuelle des fichiers dans le projet
				msg.AddString(PROJECT_FILE_NAME,nameEntry);
				for(int32 i=0;i<inProject.FileCount();i++)
				{
					inProject.GetNthFile(file,i);
					msg.AddString(FILE_PATHNAME,file.path);
				}
				
				_handler.SendMessage(&msg);				
			}
			break;
		case kProjectClosed:
		case kPrefsChanged:
		case kBuildStarted:
		case kFilesRearranged:
		case kRunMenuItemChanged:
			// on bouge un item dans le projet
		case kLinkDone:
			// Don't do anything for now
			break;
	}
}
